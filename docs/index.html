<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Google Analytics will be loaded after cookie consent -->
    
    <!-- Theme colors for different modes -->
    <meta name="theme-color" content="#667eea" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#1a1a2e" media="(prefers-color-scheme: dark)">
    <meta name="theme-color" content="#667eea">
    
    <!-- Mobile web app meta tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Hitas hintalaskuri">
    
    <title>Hitas hintalaskuri</title>
    <meta name="description" content="Laske Hitas-asuntosi nykyinen velaton enimmäishinta käyttäen virallisia rakennuskustannus- ja markkinahintaindeksejä.">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:locale" content="fi_FI">
    <meta property="og:url" content="https://vepasto.github.io/rajahinta/">
    <meta property="og:title" content="Hitas hintalaskuri">
    <meta property="og:description" content="Laske Hitas-asuntosi nykyinen velaton enimmäishinta käyttäen virallisia rakennuskustannus- ja markkinahintaindeksejä.">
    <!-- Landscape image for Facebook/Twitter -->
    <meta property="og:image" content="https://vepasto.github.io/rajahinta/og-image.png">
    <meta property="og:image:secure_url" itemprop="image" content="https://vepasto.github.io/rajahinta/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="Valkoinen talo-ikoni violettisella gradient-taustalla">
    <!-- Square image for WhatsApp (must be last og:image) -->
    <meta property="og:image" content="https://vepasto.github.io/rajahinta/og-image-square.png">
    <meta property="og:image:secure_url" itemprop="image" content="https://vepasto.github.io/rajahinta/og-image-square.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="1200">
    <meta property="og:image:alt" content="Valkoinen talo-ikoni violettisella gradient-taustalla">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://vepasto.github.io/rajahinta/">
    <meta name="twitter:title" content="Hitas hintalaskuri">
    <meta name="twitter:description" content="Laske Hitas-asuntosi nykyinen velaton enimmäishinta käyttäen virallisia rakennuskustannus- ja markkinahintaindeksejä.">
    <meta name="twitter:image" content="https://vepasto.github.io/rajahinta/og-image.png">
    
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='bg' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23667eea'/%3E%3Cstop offset='100%25' style='stop-color:%23764ba2'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' fill='url(%23bg)'/%3E%3Cg fill='white'%3E%3Cpath d='M50 25 L70 45 L70 75 L30 75 L30 45 Z'/%3E%3Crect x='40' y='55' width='8' height='12'/%3E%3Crect x='52' y='55' width='8' height='12'/%3E%3C/g%3E%3C/svg%3E">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/calculator.css">
    <!-- Inline styles removed - now using external CSS modules -->
    
</head>
<body>
    <a href="#main-content" class="skip-link">Siirry sisältöön</a>
    
    <nav class="top-nav">
        <div class="nav-container">
            <div class="nav-links">
                <a href="./" class="nav-link active">Hintalaskuri</a>
                <a href="./info/" class="nav-link">Info</a>
                <a href="./graphs/" class="nav-link">Graafit</a>
            </div>
            <button class="theme-toggle" id="themeToggle" aria-label="Vaihda teemaa" aria-live="polite">
                <span class="theme-icon" id="lightIcon">☼</span>
                <span class="theme-icon" id="darkIcon">☾</span>
            </button>
        </div>
    </nav>
    
    <header class="header">
        <h1>Hitas hintalaskuri</h1>
        <p class="subtitle">Laske Hitas-asuntosi nykyinen velaton enimmäishinta</p>
    </header>

    <main id="main-content" class="container">
        <form id="calculatorForm">
            <div class="form-group">
                <label for="originalPrice">Alkuperäinen velaton hankintahinta (€)</label>
                <input type="number" id="originalPrice" name="originalPrice" required min="0" max="999999999">
            </div>

            <div class="form-group">
                <label for="apartmentSize">Asunnon pinta-ala (m²)</label>
                <input type="number" id="apartmentSize" name="apartmentSize" required min="1" step="0.5" max="9999">
            </div>

            <div class="form-section-title">Valmistumisaika</div>

            <div class="form-row">
                <div class="form-group">
                    <label for="purchaseYear">Vuosi</label>
                    <select id="purchaseYear" name="purchaseYear" required></select>
                </div>

                <div class="form-group">
                    <label for="purchaseMonth">Kuukausi</label>
                    <select id="purchaseMonth" name="purchaseMonth" required>
                        <option value="1">Tammikuu</option>
                        <option value="2">Helmikuu</option>
                        <option value="3">Maaliskuu</option>
                        <option value="4">Huhtikuu</option>
                        <option value="5">Toukokuu</option>
                        <option value="6">Kesäkuu</option>
                        <option value="7">Heinäkuu</option>
                        <option value="8">Elokuu</option>
                        <option value="9">Syyskuu</option>
                        <option value="10">Lokakuu</option>
                        <option value="11">Marraskuu</option>
                        <option value="12">Joulukuu</option>
                    </select>
                </div>
            </div>

            <div class="improvements-section">
                <div class="form-section-title">Yhtiön parannukset</div>
                <div id="improvementsList"></div>
                <button type="button" class="btn-add-improvement" id="addImprovementBtn">+ Lisää parannus</button>
            </div>

            <div class="button-group">
                <button type="submit" class="btn-primary">Laske enimmäishinta</button>
            </div>

            <div class="disclaimer" style="margin-top: 8px; padding: 8px 12px; background: rgba(255, 255, 255, 0.5); border-radius: 8px; text-align: center; font-size: 13px; color: #666;">
                <em>Huom! Tämä on epävirallinen lomake ja tarkoitettu vain suuntaa antavaksi.</em>
            </div>
        </form>

        <div id="result" class="result" role="region" aria-live="polite" aria-atomic="true">
            <div class="result-title">Velaton enimmäishinta</div>
            <div class="result-price" id="resultPrice" aria-label="Laskettu enimmäishinta"></div>
            <div class="result-change" id="resultChange" aria-label="Hinnanmuutos"></div>
            <div class="result-improvements" id="resultImprovements" aria-label="Parannukset" style="display: none;"></div>
            <div class="price-chart-container" id="priceChartContainer" style="display: none;">
                <button class="fullscreen-chart-btn" id="fullscreenChartBtn" aria-label="Avaa graafi täysikokoisena" title="Avaa graafi täysikokoisena">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                    </svg>
                </button>
                <canvas id="priceChart"></canvas>
                <div id="chartNote" style="margin-top: 12px; padding: 10px; background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107; font-size: 13px; display: none;"></div>
            </div>
            
            <!-- Full-screen chart modal -->
            <div class="chart-modal" id="chartModal" style="display: none;">
                <div class="chart-modal-content">
                    <button class="close-chart-modal" id="closeChartModal" aria-label="Sulje graafi">×</button>
                    <div class="chart-modal-chart-container">
                        <canvas id="priceChartModal"></canvas>
                    </div>
                </div>
            </div>
            <button class="calculation-toggle" id="calculationToggle" aria-expanded="false" aria-controls="resultInfo">
                <strong>Laskenta</strong>
                <span class="toggle-arrow" aria-hidden="true">▼</span>
            </button>
            <div class="result-info" id="resultInfo" role="region" aria-label="Laskentadetaljit" aria-hidden="true"></div>
        </div>

        <div style="text-align: center; margin-top: 30px;">
            <a href="./info/" style="color: #667eea; text-decoration: none; font-weight: 500; font-size: 14px; display: inline-flex; align-items: center; gap: 5px; opacity: 0.85; transition: opacity 0.3s;">
                → Lue lisää Hitas-asunnoista ja hinnoittelusta
            </a>
        </div>
    </main>

    <footer class="footer">
        <p style="display: flex; align-items: center; justify-content: center; gap: 5px;">
            <span>vibe coded by</span>
            <a href="https://github.com/vepasto" target="_blank" rel="noopener noreferrer" style="display: flex; align-items: center; gap: 5px; text-decoration: none; color: white;" aria-label="GitHub profiili: vepasto">
                <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                vepasto
            </a>
        </p>
        <a href="https://github.com/vepasto/rajahinta/issues" target="_blank" rel="noopener noreferrer" class="bug-report-link">
            Löysitkö bugin?
        </a>
    </footer>

    <script>
        // Indeksit ladataan JSON-tiedostosta
        let rakennuskustannusindeksi = {};
        let markkinahintaindeksi = {};
        let vanhatMarkkinahintaindeksi = {};
        let rajaneliohinta = null;
        let indicesLoaded = false;
        let indicesData = null; // Store raw JSON data for charts

        // Find the latest indices file by trying dates backwards from today
        async function findLatestIndicesFile() {
            const maxDaysBack = 30; // Try up to 30 days back
            
            // Start from today and go backwards
            const today = new Date();
            for (let daysBack = 0; daysBack < maxDaysBack; daysBack++) {
                const date = new Date(today);
                date.setDate(date.getDate() - daysBack);
                
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const filename = `data/indices-${year}-${month}-${day}.json`;
                
                try {
                    const response = await fetch(filename);
                    if (response.ok) {
                        return filename;
                    }
                } catch (e) {
                    continue;
                }
            }
            
            throw new Error('Could not find any indices file');
        }

        // Validate indices data structure
        function validateIndicesData(data) {
            const errors = [];
            
            // Check required fields
            if (!data) {
                errors.push('Data is null or undefined');
                return errors;
            }
            
            if (!data.rakennuskustannusindeksi || typeof data.rakennuskustannusindeksi !== 'object') {
                errors.push('rakennuskustannusindeksi is missing or invalid');
            }
            
            if (!data.markkinahintaindeksi || typeof data.markkinahintaindeksi !== 'object') {
                errors.push('markkinahintaindeksi is missing or invalid');
            }
            
            // Optional fields (just log warnings)
            if (data.vanhat_markkinahintaindeksi && typeof data.vanhat_markkinahintaindeksi !== 'object') {
                console.warn('vanhat_markkinahintaindeksi has invalid format');
            }
            
            if (data.rajaneliohinta && typeof data.rajaneliohinta !== 'object') {
                console.warn('rajaneliohinta has invalid format');
            }
            
            return errors;
        }

        // Safely parse index data with error handling
        function parseIndexData(indexData, indexName) {
            const parsed = {};
            
            if (!indexData || typeof indexData !== 'object') {
                console.warn(`${indexName} is missing or invalid`);
                return parsed;
            }
            
            try {
                for (const [yearStr, months] of Object.entries(indexData)) {
                    const year = parseInt(yearStr);
                    if (isNaN(year)) {
                        console.warn(`Invalid year in ${indexName}: ${yearStr}`);
                        continue;
                    }
                    
                    parsed[year] = {};
                    if (!months || typeof months !== 'object') {
                        console.warn(`Invalid months data for year ${year} in ${indexName}`);
                        continue;
                    }
                    
                    for (const [monthStr, value] of Object.entries(months)) {
                        const month = parseInt(monthStr);
                        if (isNaN(month) || month < 1 || month > 12) {
                            console.warn(`Invalid month in ${indexName} for year ${year}: ${monthStr}`);
                            continue;
                        }
                        
                        const numValue = typeof value === 'number' ? value : parseFloat(value);
                        if (isNaN(numValue)) {
                            console.warn(`Invalid value in ${indexName} for ${year}-${month}: ${value}`);
                            continue;
                        }
                        
                        parsed[year][month] = numValue;
                    }
                }
            } catch (error) {
                console.error(`Error parsing ${indexName}:`, error);
            }
            
            return parsed;
        }

        // Lataa indeksit JSON-tiedostosta
        async function loadIndices() {
            try {
                // Find the latest indices file automatically
                const indicesFile = await findLatestIndicesFile();
                const response = await fetch(indicesFile);
                if (!response.ok) {
                    throw new Error(`Failed to load indices file: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Validate data structure
                const validationErrors = validateIndicesData(data);
                if (validationErrors.length > 0) {
                    throw new Error(`Invalid indices data structure: ${validationErrors.join(', ')}`);
                }
                
                // Store raw data for charts
                indicesData = data;
                
                // Parse indices data safely
                rakennuskustannusindeksi = parseIndexData(data.rakennuskustannusindeksi, 'rakennuskustannusindeksi');
                markkinahintaindeksi = parseIndexData(data.markkinahintaindeksi, 'markkinahintaindeksi');
                
                // Parse optional indices
                if (data.vanhat_markkinahintaindeksi) {
                    vanhatMarkkinahintaindeksi = parseIndexData(data.vanhat_markkinahintaindeksi, 'vanhat_markkinahintaindeksi');
                } else {
                    vanhatMarkkinahintaindeksi = {};
                }
                
                // Parse rajaneliöhinta safely
                if (data.rajaneliohinta) {
                    try {
                        // Validate rajaneliöhinta structure
                        if (typeof data.rajaneliohinta === 'object' && 
                            typeof data.rajaneliohinta.price_per_sqm === 'number' &&
                            data.rajaneliohinta.valid_from &&
                            data.rajaneliohinta.valid_until) {
                            rajaneliohinta = data.rajaneliohinta;
                        } else {
                            console.warn('rajaneliohinta has invalid structure, skipping');
                            rajaneliohinta = null;
                        }
                    } catch (error) {
                        console.error('Error parsing rajaneliohinta:', error);
                        rajaneliohinta = null;
                    }
                } else {
                    rajaneliohinta = null;
                }
                
                // Check if we have minimum required data
                const hasRakennuskustannus = Object.keys(rakennuskustannusindeksi).length > 0;
                const hasMarkkinahinta = Object.keys(markkinahintaindeksi).length > 0;
                
                if (!hasRakennuskustannus || !hasMarkkinahinta) {
                    throw new Error('Required indices data is empty or invalid');
                }
                
                indicesLoaded = true;
                return true;
            } catch (error) {
                console.error('Error loading indices:', error);
                indicesLoaded = false;
                // Show user-friendly error message without blocking page load
                const errorMsg = error.message || 'Tuntematon virhe';
                // Use setTimeout to avoid blocking page load in Safari
                setTimeout(() => {
                    const errorDiv = document.createElement('div');
                    errorDiv.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #e74c3c; color: white; padding: 15px 20px; border-radius: 8px; z-index: 10000; max-width: 90%; box-shadow: 0 4px 6px rgba(0,0,0,0.3);';
                    errorDiv.innerHTML = `<strong>Virhe:</strong> Indeksien lataus epäonnistui.<br><br>${errorMsg}<br><br><button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: white; color: #e74c3c; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Päivitä sivu</button>`;
                    document.body.appendChild(errorDiv);
                    // Auto-remove after 10 seconds
                    setTimeout(() => {
                        if (errorDiv.parentNode) {
                            errorDiv.parentNode.removeChild(errorDiv);
                        }
                    }, 10000);
                }, 100);
                return false;
            }
        }

        const monthNames = ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Kesäkuu', 
                           'Heinäkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'];

        // Initialize year dropdown
        function initializeYearDropdown() {
            const yearSelect = document.getElementById('purchaseYear');
            const currentYear = new Date().getFullYear();
            const startYear = 1978; // Vanhemmat indeksit alkavat 1978 alkaen
            
            for (let year = currentYear; year >= startYear; year--) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearSelect.appendChild(option);
            }
        }

        // Initialize year dropdown for improvements
        function initializeImprovementYearDropdown(selectElement, selectedYear = null) {
            const currentYear = new Date().getFullYear();
            const startYear = 1978;
            
            selectElement.innerHTML = '';
            for (let year = currentYear; year >= startYear; year--) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                if (selectedYear && year === selectedYear) {
                    option.selected = true;
                }
                selectElement.appendChild(option);
            }
        }

        // Improvements management
        let improvementCounter = 0;

        // Update improvement numbering dynamically
        function updateImprovementNumbers() {
            const improvementItems = document.querySelectorAll('.improvement-item');
            improvementItems.forEach((item, index) => {
                const titleElement = item.querySelector('.improvement-item-title');
                if (titleElement) {
                    titleElement.textContent = `Parannus ${index + 1}`;
                }
            });
        }

        function addImprovement(improvementData = null) {
            const improvementsList = document.getElementById('improvementsList');
            const improvementIndex = improvementCounter++;
            
            const improvementItem = document.createElement('div');
            improvementItem.className = 'improvement-item';
            improvementItem.dataset.index = improvementIndex;
            
            const price = improvementData ? improvementData.price : '';
            const year = improvementData ? improvementData.year : null;
            const month = improvementData ? improvementData.month : null;
            
            // Get current number of improvements for display
            const currentCount = improvementsList.children.length;
            
            improvementItem.innerHTML = `
                <div class="improvement-item-header">
                    <span class="improvement-item-title">Parannus ${currentCount + 1}</span>
                    <button type="button" class="btn-remove" onclick="removeImprovement(${improvementIndex})">Poista</button>
                </div>
                <div class="form-group">
                    <label for="improvementPrice_${improvementIndex}" class="label-with-tooltip">
                        <span>Huoneistoon kohdistuva hinta (€)</span>
                        <span class="info-tooltip">
                            <span class="info-icon">?</span>
                            <span class="tooltip-content">
                                Huoneiston osuus lasketaan huoneiston ja yhtiön pinta-alojen suhteessa.<br>
                                Esim. huoneisto 60 m² / yhtiö 2400 m² = 2,5%
                            </span>
                        </span>
                    </label>
                    <input type="number" id="improvementPrice_${improvementIndex}" 
                           class="improvement-price" data-index="${improvementIndex}" 
                           min="0" step="1" value="${price}">
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="improvementYear_${improvementIndex}">Valmistumisvuosi</label>
                        <select id="improvementYear_${improvementIndex}" 
                                class="improvement-year" data-index="${improvementIndex}"></select>
                    </div>
                    <div class="form-group">
                        <label for="improvementMonth_${improvementIndex}">Valmistumiskuukausi</label>
                        <select id="improvementMonth_${improvementIndex}" 
                                class="improvement-month" data-index="${improvementIndex}">
                            <option value="1" ${month === 1 ? 'selected' : ''}>Tammikuu</option>
                            <option value="2" ${month === 2 ? 'selected' : ''}>Helmikuu</option>
                            <option value="3" ${month === 3 ? 'selected' : ''}>Maaliskuu</option>
                            <option value="4" ${month === 4 ? 'selected' : ''}>Huhtikuu</option>
                            <option value="5" ${month === 5 ? 'selected' : ''}>Toukokuu</option>
                            <option value="6" ${month === 6 ? 'selected' : ''}>Kesäkuu</option>
                            <option value="7" ${month === 7 ? 'selected' : ''}>Heinäkuu</option>
                            <option value="8" ${month === 8 ? 'selected' : ''}>Elokuu</option>
                            <option value="9" ${month === 9 ? 'selected' : ''}>Syyskuu</option>
                            <option value="10" ${month === 10 ? 'selected' : ''}>Lokakuu</option>
                            <option value="11" ${month === 11 ? 'selected' : ''}>Marraskuu</option>
                            <option value="12" ${month === 12 ? 'selected' : ''}>Joulukuu</option>
                        </select>
                    </div>
                </div>
            `;
            
            improvementsList.appendChild(improvementItem);
            
            // Initialize year dropdown
            const yearSelect = document.getElementById(`improvementYear_${improvementIndex}`);
            initializeImprovementYearDropdown(yearSelect, year);
            
            // Update all numbers
            updateImprovementNumbers();
            
            // Update localStorage with current improvements
            const savedData = loadFromLocalStorage();
            if (savedData) {
                const currentImprovements = getImprovements();
                saveToLocalStorage({
                    ...savedData,
                    improvements: currentImprovements
                });
            }
        }

        // Make removeImprovement globally accessible
        window.removeImprovement = function(index) {
            const improvementItem = document.querySelector(`.improvement-item[data-index="${index}"]`);
            if (improvementItem) {
                improvementItem.remove();
                // Update numbering after removal
                updateImprovementNumbers();
                
                // Update localStorage with current improvements
                const savedData = loadFromLocalStorage();
                if (savedData) {
                    const currentImprovements = getImprovements();
                    saveToLocalStorage({
                        ...savedData,
                        improvements: currentImprovements
                    });
                }
            }
        };

        function getImprovements() {
            const improvements = [];
            const improvementItems = document.querySelectorAll('.improvement-item');
            
            improvementItems.forEach(item => {
                const index = item.dataset.index;
                const priceInput = document.getElementById(`improvementPrice_${index}`);
                const yearSelect = document.getElementById(`improvementYear_${index}`);
                const monthSelect = document.getElementById(`improvementMonth_${index}`);
                
                if (priceInput && yearSelect && monthSelect) {
                    const price = parseFloat(priceInput.value);
                    const year = parseInt(yearSelect.value);
                    const month = parseInt(monthSelect.value);
                    
                    if (!isNaN(price) && price > 0 && year && month) {
                        improvements.push({ price, year, month });
                    }
                }
            });
            
            return improvements;
        }

        // Get the latest available index value (not in the future)
        function getLatestIndex(indexData) {
            // Validate input
            if (!indexData || typeof indexData !== 'object' || Object.keys(indexData).length === 0) {
                return null;
            }
            
            try {
                const currentDate = new Date();
                const currentYear = currentDate.getFullYear();
                const currentMonth = currentDate.getMonth() + 1; // JavaScript months are 0-11
                
                const years = Object.keys(indexData).map(Number).filter(y => !isNaN(y)).sort((a, b) => b - a);
                
                for (const year of years) {
                    // Skip future years
                    if (year > currentYear) continue;
                    
                    if (!indexData[year] || typeof indexData[year] !== 'object') {
                        continue;
                    }
                    
                    const months = Object.keys(indexData[year]).map(Number).filter(m => !isNaN(m)).sort((a, b) => b - a);
                    for (const month of months) {
                        // Skip future months in current year
                        if (year === currentYear && month > currentMonth) continue;
                        
                        const value = indexData[year][month];
                        if (typeof value === 'number' && !isNaN(value)) {
                            return {
                                value: value,
                                year: year,
                                month: month
                            };
                        }
                    }
                }
            } catch (error) {
                console.error('Error in getLatestIndex:', error);
            }
            
            return null;
        }

        // Get index value for a specific date
        function getIndexValue(indexData, year, month) {
            // Validate input
            if (!indexData || typeof indexData !== 'object') {
                return null;
            }
            
            if (typeof year !== 'number' || isNaN(year) || typeof month !== 'number' || isNaN(month)) {
                return null;
            }
            
            try {
                if (indexData[year] && typeof indexData[year] === 'object' && 
                    indexData[year][month] !== undefined) {
                    const value = indexData[year][month];
                    if (typeof value === 'number' && !isNaN(value)) {
                        return value;
                    }
                }
            } catch (error) {
                console.error('Error in getIndexValue:', error);
            }
            
            return null;
        }

        // Format price in euros
        function formatPrice(price) {
            return new Intl.NumberFormat('fi-FI', {
                style: 'currency',
                currency: 'EUR',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(price);
        }

        // Format price compactly for charts (e.g., 305000 -> 305k €)
        function formatPriceCompact(price) {
            if (price >= 1000) {
                return Math.round(price / 1000) + 'k €';
            }
            return Math.round(price) + ' €';
        }

        // Calculate indexed value for a single improvement
        function getImprovementIndexedValue(improvement, apartmentSize) {
            const omavastuu = apartmentSize * 30; // 30 €/m²
            
            // If improvement price is less than or equal to omavastuu, no indexing
            if (improvement.price <= omavastuu) {
                return {
                    originalPrice: improvement.price,
                    omavastuu: omavastuu,
                    indexedValue: 0,
                    indexedAmount: 0,
                    usedIndex: null,
                    improvementYear: improvement.year,
                    improvementMonth: improvement.month
                };
            }
            
            // Amount to be indexed (price exceeding omavastuu)
            const amountToIndex = improvement.price - omavastuu;
            
            // Check if improvement was completed before 2011
            const isBefore2011 = improvement.year < 2011;
            
            let indexedValue = 0;
            let usedIndex = null;
            
            if (isBefore2011) {
                // Use old market price index
                const improvementOldMarket = getIndexValue(vanhatMarkkinahintaindeksi, improvement.year, improvement.month);
                const currentOldMarket = getLatestIndex(vanhatMarkkinahintaindeksi);
                
                if (improvementOldMarket && currentOldMarket) {
                    indexedValue = (amountToIndex * currentOldMarket.value) / improvementOldMarket;
                    usedIndex = {
                        name: 'Vanhojen osakeasuntojen hintaindeksi',
                        type: 'vanhatMarkkinahinta',
                        improvementIndex: improvementOldMarket,
                        currentIndex: currentOldMarket
                    };
                }
            } else {
                // Use both indices and choose the higher one
                const improvementRk = getIndexValue(rakennuskustannusindeksi, improvement.year, improvement.month);
                const improvementMh = getIndexValue(markkinahintaindeksi, improvement.year, improvement.month);
                const currentRk = getLatestIndex(rakennuskustannusindeksi);
                const currentMh = getLatestIndex(markkinahintaindeksi);
                
                let rkValue = 0;
                let mhValue = 0;
                
                if (improvementRk && currentRk) {
                    rkValue = (amountToIndex * currentRk.value) / improvementRk;
                }
                
                if (improvementMh && currentMh) {
                    mhValue = (amountToIndex * currentMh.value) / improvementMh;
                }
                
                // Choose the higher value
                if (rkValue >= mhValue && rkValue > 0) {
                    indexedValue = rkValue;
                    usedIndex = {
                        name: 'Rakennuskustannusindeksi',
                        type: 'rakennuskustannus',
                        improvementIndex: improvementRk,
                        currentIndex: currentRk
                    };
                } else if (mhValue > 0) {
                    indexedValue = mhValue;
                    usedIndex = {
                        name: 'Markkinahintaindeksi',
                        type: 'markkinahinta',
                        improvementIndex: improvementMh,
                        currentIndex: currentMh
                    };
                }
            }
            
            return {
                originalPrice: improvement.price,
                omavastuu: omavastuu,
                indexedValue: indexedValue,
                indexedAmount: amountToIndex,
                usedIndex: usedIndex,
                improvementYear: improvement.year,
                improvementMonth: improvement.month
            };
        }

        // Calculate total improvements impact
        function calculateImprovements(improvements, apartmentSize) {
            if (!improvements || improvements.length === 0) {
                return {
                    totalIndexedValue: 0,
                    improvements: []
                };
            }
            
            const improvementResults = improvements.map(improvement => 
                getImprovementIndexedValue(improvement, apartmentSize)
            );
            
            const totalIndexedValue = improvementResults.reduce((sum, result) => sum + result.indexedValue, 0);
            
            return {
                totalIndexedValue: totalIndexedValue,
                improvements: improvementResults
            };
        }

        // Calculate rajahinta
        function calculateRajahinta(originalPrice, purchaseYear, purchaseMonth, apartmentSize, improvements = []) {
            const results = {
                rakennuskustannus: null,
                markkinahinta: null,
                vanhatMarkkinahinta: null,
                rajaneliohinta: null,
                improvements: null
            };

            // Check if apartment was completed before 2011
            const isBefore2011 = purchaseYear < 2011;

            if (isBefore2011) {
                // Use old market price index for apartments completed before 2011
                const purchaseOldMarket = getIndexValue(vanhatMarkkinahintaindeksi, purchaseYear, purchaseMonth);
                const currentOldMarket = getLatestIndex(vanhatMarkkinahintaindeksi);

                if (purchaseOldMarket && currentOldMarket) {
                    results.vanhatMarkkinahinta = {
                        price: (originalPrice * currentOldMarket.value) / purchaseOldMarket,
                        currentIndex: currentOldMarket,
                        purchaseIndex: purchaseOldMarket
                    };
                }
            } else {
                // Use rakennuskustannus and markkinahinta indices for apartments from 2011 onwards
                // Get purchase indices
                const purchaseRakennuskustannus = getIndexValue(rakennuskustannusindeksi, purchaseYear, purchaseMonth);
                const purchaseMarkkinahinta = getIndexValue(markkinahintaindeksi, purchaseYear, purchaseMonth);

                // Get current indices
                const currentRakennuskustannus = getLatestIndex(rakennuskustannusindeksi);
                const currentMarkkinahinta = getLatestIndex(markkinahintaindeksi);

                // Calculate with Rakennuskustannusindeksi
                if (purchaseRakennuskustannus && currentRakennuskustannus) {
                    results.rakennuskustannus = {
                        price: (originalPrice * currentRakennuskustannus.value) / purchaseRakennuskustannus,
                        currentIndex: currentRakennuskustannus,
                        purchaseIndex: purchaseRakennuskustannus
                    };
                }

                // Calculate with Markkinahintaindeksi
                if (purchaseMarkkinahinta && currentMarkkinahinta) {
                    results.markkinahinta = {
                        price: (originalPrice * currentMarkkinahinta.value) / purchaseMarkkinahinta,
                        currentIndex: currentMarkkinahinta,
                        purchaseIndex: purchaseMarkkinahinta
                    };
                }
            }

            // Calculate improvements impact
            if (improvements && improvements.length > 0) {
                const improvementsResult = calculateImprovements(improvements, apartmentSize);
                results.improvements = improvementsResult;
                
                // Add improvements to index prices (not to rajaneliöhinta)
                if (results.rakennuskustannus) {
                    results.rakennuskustannus.price += improvementsResult.totalIndexedValue;
                }
                if (results.markkinahinta) {
                    results.markkinahinta.price += improvementsResult.totalIndexedValue;
                }
                if (results.vanhatMarkkinahinta) {
                    results.vanhatMarkkinahinta.price += improvementsResult.totalIndexedValue;
                }
            }

            // Calculate rajaneliöhinta (applies to all Hitas apartments, improvements NOT added)
            if (rajaneliohinta && apartmentSize) {
                results.rajaneliohinta = {
                    price: apartmentSize * rajaneliohinta.price_per_sqm,
                    pricePerSqm: rajaneliohinta.price_per_sqm,
                    apartmentSize: apartmentSize,
                    validFrom: rajaneliohinta.valid_from,
                    validUntil: rajaneliohinta.valid_until
                };
            }

            return results;
        }

        // Save to localStorage
        function saveToLocalStorage(data) {
            localStorage.setItem('hitasCalculatorData', JSON.stringify(data));
        }

        // Load from localStorage
        function loadFromLocalStorage() {
            const data = localStorage.getItem('hitasCalculatorData');
            return data ? JSON.parse(data) : null;
        }

        // Clear localStorage
        function clearLocalStorage() {
            localStorage.removeItem('hitasCalculatorData');
        }

        // Display result
        let priceChartInstance = null;
        let priceChartModalInstance = null; // Chart instance for modal
        let currentChartData = null; // Store current chart data for theme switching

        function createPriceChart(purchaseYear, purchaseMonth, originalPrice, apartmentSize = null, winner = null) {
            const chartContainer = document.getElementById('priceChartContainer');
            const canvas = document.getElementById('priceChart');
            
            // Store data for theme switching
            currentChartData = { purchaseYear, purchaseMonth, originalPrice, apartmentSize, winner };
            
            // Destroy existing chart
            if (priceChartInstance) {
                priceChartInstance.destroy();
                priceChartInstance = null;
            }
            
            // Helper function to convert index object to sorted data points
            function getDataPoints(indexDataObj, purchaseIndex) {
                const currentDate = new Date();
                const currentYear = currentDate.getFullYear();
                const currentMonth = currentDate.getMonth() + 1;
                
                const dataPoints = [];
                for (const [year, months] of Object.entries(indexDataObj)) {
                    for (const [month, value] of Object.entries(months)) {
                        const y = parseInt(year);
                        const m = parseInt(month);
                        
                        // Only include data from purchase date onwards, but not in the future
                        const isAfterPurchase = y > purchaseYear || (y === purchaseYear && m >= purchaseMonth);
                        const isNotFuture = y < currentYear || (y === currentYear && m <= currentMonth);
                        
                        if (isAfterPurchase && isNotFuture) {
                            dataPoints.push({
                                year: y,
                                month: m,
                                value: value,
                                price: (value / purchaseIndex) * originalPrice
                            });
                        }
                    }
                }
                // Sort by year and month
                dataPoints.sort((a, b) => {
                    if (a.year !== b.year) return a.year - b.year;
                    return a.month - b.month;
                });
                return dataPoints;
            }
            
            // Prepare datasets
            const datasets = [];
            let labels = [];
            
            // For post-2011 apartments, show both indices
            if (purchaseYear >= 2011) {
                // Get both index data
                const rkPurchaseIndex = rakennuskustannusindeksi[purchaseYear]?.[purchaseMonth];
                const mhPurchaseIndex = markkinahintaindeksi[purchaseYear]?.[purchaseMonth];
                
                if (rkPurchaseIndex && mhPurchaseIndex) {
                    const rkDataPoints = getDataPoints(indicesData.rakennuskustannusindeksi, rkPurchaseIndex);
                    const mhDataPoints = getDataPoints(indicesData.markkinahintaindeksi, mhPurchaseIndex);
                    
                    if (rkDataPoints.length > 0 && mhDataPoints.length > 0) {
                        // Use the longer array for labels
                        const allLabels = new Set();
                        rkDataPoints.forEach(dp => allLabels.add(`${dp.month}/${dp.year}`));
                        mhDataPoints.forEach(dp => allLabels.add(`${dp.month}/${dp.year}`));
                        
                        // Create label-to-data maps
                        const rkMap = new Map(rkDataPoints.map(dp => [`${dp.month}/${dp.year}`, dp.price]));
                        const mhMap = new Map(mhDataPoints.map(dp => [`${dp.month}/${dp.year}`, dp.price]));
                        
                        // Sort labels chronologically
                        labels = Array.from(allLabels).sort((a, b) => {
                            const [m1, y1] = a.split('/').map(Number);
                            const [m2, y2] = b.split('/').map(Number);
                            if (y1 !== y2) return y1 - y2;
                            return m1 - m2;
                        });
                        
                        // Add purchase point at the beginning
                        labels.unshift(`${purchaseMonth}/${purchaseYear}`);
                        
                        const rkPrices = [originalPrice, ...labels.slice(1).map(l => rkMap.get(l) || null)];
                        const mhPrices = [originalPrice, ...labels.slice(1).map(l => mhMap.get(l) || null)];
                        
                        // Determine colors based on theme
                        const isDark = document.body.classList.contains('dark-mode') || 
                                       (!document.body.classList.contains('light-mode') && 
                                        window.matchMedia('(prefers-color-scheme: dark)').matches);
                        
                        const rkColor = isDark ? '#9ca3ff' : '#667eea';
                        const mhColor = isDark ? '#ff9cba' : '#e74c3c';
                        
                        datasets.push({
                            label: 'Rakennuskustannusindeksi',
                            data: rkPrices,
                            borderColor: rkColor,
                            backgroundColor: isDark ? 'rgba(156, 163, 255, 0.1)' : 'rgba(102, 126, 234, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 5,
                            spanGaps: true,
                            hidden: winner && winner.type !== 'rakennuskustannus'
                        });
                        
                        datasets.push({
                            label: 'Markkinahintaindeksi',
                            data: mhPrices,
                            borderColor: mhColor,
                            backgroundColor: isDark ? 'rgba(255, 156, 186, 0.1)' : 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 5,
                            spanGaps: true,
                            hidden: winner && winner.type !== 'markkinahinta'
                        });
                    }
                }
            } else {
                // For pre-2011 apartments, show only old market index
                const vmPurchaseIndex = vanhatMarkkinahintaindeksi[purchaseYear]?.[purchaseMonth];
                
                if (!vmPurchaseIndex) {
                    chartContainer.style.display = 'none';
                    return;
                }
                
                const vmDataPoints = getDataPoints(indicesData.vanhat_markkinahintaindeksi, vmPurchaseIndex);
                
                if (vmDataPoints.length === 0) {
                    chartContainer.style.display = 'none';
                    return;
                }
                
                labels = vmDataPoints.map(dp => `${dp.month}/${dp.year}`);
                const prices = vmDataPoints.map(dp => dp.price);
                
                // Add purchase point at the beginning
                labels.unshift(`${purchaseMonth}/${purchaseYear}`);
                prices.unshift(originalPrice);
                
                const isDark = document.body.classList.contains('dark-mode') || 
                               (!document.body.classList.contains('light-mode') && 
                                window.matchMedia('(prefers-color-scheme: dark)').matches);
                
                const lineColor = isDark ? '#9ca3ff' : '#667eea';
                
                datasets.push({
                    label: 'Vanhojen osakeasuntojen hintaindeksi',
                    data: prices,
                    borderColor: lineColor,
                    backgroundColor: isDark ? 'rgba(156, 163, 255, 0.1)' : 'rgba(102, 126, 234, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.1,
                    pointRadius: 0,
                    pointHoverRadius: 5,
                    hidden: winner && winner.type !== 'vanhatMarkkinahinta'
                });
            }
            
            // Add rajaneliöhinta line if apartment size is available and we have historical data
            if (apartmentSize && indicesData && indicesData.rajaneliohinta_tilasto && typeof indicesData.rajaneliohinta_tilasto === 'object') {
                try {
                    const currentDate = new Date();
                    const currentYear = currentDate.getFullYear();
                    const currentMonth = currentDate.getMonth() + 1;
                    
                    // Find the last valid rajaneliöhinta before purchase date
                    let lastRajahintaBeforePurchase = null;
                    const rajahintaYears = Object.keys(indicesData.rajaneliohinta_tilasto)
                        .map(Number)
                        .filter(y => !isNaN(y))
                        .sort((a, b) => b - a); // Sort descending to find latest first
                    
                    for (const year of rajahintaYears) {
                        if (!indicesData.rajaneliohinta_tilasto[year] || typeof indicesData.rajaneliohinta_tilasto[year] !== 'object') {
                            continue;
                        }
                        
                        const months = Object.keys(indicesData.rajaneliohinta_tilasto[year])
                            .map(Number)
                            .filter(m => !isNaN(m) && m >= 1 && m <= 12)
                            .sort((a, b) => b - a); // Sort descending
                        
                        for (const month of months) {
                            const pricePerSqm = indicesData.rajaneliohinta_tilasto[year][month];
                            if (typeof pricePerSqm === 'number' && !isNaN(pricePerSqm)) {
                                // Check if this is before purchase date
                                const isBeforePurchase = year < purchaseYear || (year === purchaseYear && month < purchaseMonth);
                                
                                if (isBeforePurchase) {
                                    lastRajahintaBeforePurchase = {
                                        year: year,
                                        month: month,
                                        pricePerSqm: pricePerSqm,
                                        price: apartmentSize * pricePerSqm
                                    };
                                    break; // Found the latest one before purchase
                                }
                            }
                        }
                        if (lastRajahintaBeforePurchase) break; // Found, exit outer loop
                    }
                    
                    // Collect rajaneliöhinta data points from purchase date onwards
                    const rajahintaDataPoints = [];
                    
                    // Add starting point using last valid rajaneliöhinta before purchase (or first available after purchase)
                    if (lastRajahintaBeforePurchase) {
                        rajahintaDataPoints.push({
                            year: purchaseYear,
                            month: purchaseMonth,
                            price: lastRajahintaBeforePurchase.price
                        });
                    }
                    
                    // Collect all data points from purchase date onwards
                    for (const year of rajahintaYears.slice().reverse()) { // Reverse to ascending order
                        if (!indicesData.rajaneliohinta_tilasto[year] || typeof indicesData.rajaneliohinta_tilasto[year] !== 'object') {
                            continue;
                        }
                        
                        const months = Object.keys(indicesData.rajaneliohinta_tilasto[year])
                            .map(Number)
                            .filter(m => !isNaN(m) && m >= 1 && m <= 12)
                            .sort((a, b) => a - b);
                        
                        for (const month of months) {
                            const pricePerSqm = indicesData.rajaneliohinta_tilasto[year][month];
                            if (typeof pricePerSqm === 'number' && !isNaN(pricePerSqm)) {
                                // Only include data from purchase date onwards, but not in the future
                                const isAfterPurchase = year > purchaseYear || (year === purchaseYear && month >= purchaseMonth);
                                const isNotFuture = year < currentYear || (year === currentYear && month <= currentMonth);
                                
                                if (isAfterPurchase && isNotFuture) {
                                    rajahintaDataPoints.push({
                                        year: year,
                                        month: month,
                                        price: apartmentSize * pricePerSqm
                                    });
                                }
                            }
                        }
                    }
                    
                    // Sort by year and month
                    rajahintaDataPoints.sort((a, b) => {
                        if (a.year !== b.year) return a.year - b.year;
                        return a.month - b.month;
                    });
                    
                    if (rajahintaDataPoints.length > 0) {
                        // Store original labels and data before merging
                        const originalLabels = [...labels];
                        const originalDatasets = datasets.map(ds => ({
                            data: [...ds.data],
                            label: ds.label
                        }));
                        
                        // Create labels for rajaneliöhinta
                        const rajahintaLabels = rajahintaDataPoints.map(dp => `${dp.month}/${dp.year}`);
                        
                        // Merge with existing labels
                        const allLabelsSet = new Set(labels);
                        rajahintaLabels.forEach(l => allLabelsSet.add(l));
                        
                        // Sort labels chronologically
                        const allLabelsArray = Array.from(allLabelsSet).sort((a, b) => {
                            const [m1, y1] = a.split('/').map(Number);
                            const [m2, y2] = b.split('/').map(Number);
                            if (y1 !== y2) return y1 - y2;
                            return m1 - m2;
                        });
                        
                        // Create map for rajaneliöhinta prices
                        const rajahintaMap = new Map(rajahintaDataPoints.map(dp => [`${dp.month}/${dp.year}`, dp.price]));
                        
                        // Create price array matching all labels
                        const rajahintaPrices = allLabelsArray.map(l => rajahintaMap.get(l) || null);
                        
                        // Update labels to include all points
                        labels = allLabelsArray;
                        
                        // Update existing datasets to match new labels
                        datasets.forEach((dataset, index) => {
                            const originalData = originalDatasets[index].data;
                            const newData = allLabelsArray.map(l => {
                                const oldIndex = originalLabels.indexOf(l);
                                return oldIndex >= 0 ? originalData[oldIndex] : null;
                            });
                            dataset.data = newData;
                        });
                        
                        // Determine colors based on theme
                        const isDark = document.body.classList.contains('dark-mode') || 
                                       (!document.body.classList.contains('light-mode') && 
                                        window.matchMedia('(prefers-color-scheme: dark)').matches);
                        
                        const rajahintaColor = isDark ? '#ffa94d' : '#ff8c00';
                        
                        datasets.push({
                            label: 'Rajaneliöhinta',
                            data: rajahintaPrices,
                            borderColor: rajahintaColor,
                            backgroundColor: isDark ? 'rgba(255, 169, 77, 0.1)' : 'rgba(255, 140, 0, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 5,
                            spanGaps: true,
                            borderDash: [5, 5], // Dashed line to distinguish from index lines
                            hidden: winner && winner.type !== 'rajaneliohinta'
                        });
                    }
                } catch (error) {
                    console.error('Error adding rajaneliöhinta to chart:', error);
                }
            }
            
            if (datasets.length === 0 || labels.length === 0) {
                chartContainer.style.display = 'none';
                return;
            }
            
            // Determine if dark mode
            const isDark = document.body.classList.contains('dark-mode') || 
                           (!document.body.classList.contains('light-mode') && 
                            window.matchMedia('(prefers-color-scheme: dark)').matches);
            
            const textColor = isDark ? '#d0d0d0' : '#333';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.15)';
            
            // Use smaller aspect ratio on mobile for taller chart
            const isMobile = window.innerWidth <= 768;
            const aspectRatio = isMobile ? 0.8 : 1.2; // Much taller chart on mobile
            
            chartContainer.style.display = 'block';
            
            priceChartInstance = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: aspectRatio,
                    plugins: {
                        legend: {
                            display: datasets.length > 1,
                            position: 'top',
                            labels: {
                                color: textColor,
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return formatPrice(context.parsed.y);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: textColor,
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 20
                            },
                            grid: {
                                color: gridColor
                            }
                        },
                        y: {
                            ticks: {
                                color: textColor,
                                callback: function(value) {
                                    return formatPriceCompact(value);
                                }
                            },
                            grid: {
                                color: gridColor
                            }
                        }
                    }
                }
            });
        }

        // Create chart in modal
        function createModalChart() {
            if (!currentChartData || !priceChartInstance) {
                return;
            }

            const modal = document.getElementById('chartModal');
            const modalChartContainer = document.querySelector('.chart-modal-chart-container');
            
            if (!modal || !modalChartContainer) {
                return;
            }

            // Ensure modal is properly closed/reset before opening
            if (modal.style.display === 'flex') {
                closeModalChart();
                return;
            }
            
            // Destroy existing modal chart if any
            if (priceChartModalInstance) {
                try {
                    priceChartModalInstance.destroy();
                } catch (e) {
                    console.error('Error destroying existing modal chart:', e);
                }
                priceChartModalInstance = null;
            }
            
            // Remove old canvas and create new one to avoid Chart.js issues
            const oldCanvas = document.getElementById('priceChartModal');
            if (oldCanvas) {
                oldCanvas.remove();
            }
            
            // Create fresh canvas element
            const modalCanvas = document.createElement('canvas');
            modalCanvas.id = 'priceChartModal';
            modalChartContainer.appendChild(modalCanvas);

            // Show modal first so canvas has proper dimensions
            modal.style.display = 'flex';
            document.body.classList.add('modal-open');
            document.body.style.overflow = 'hidden';
            
            // Request fullscreen if supported
            if (modal.requestFullscreen) {
                modal.requestFullscreen().catch(err => {
                    console.log('Fullscreen request failed:', err);
                });
            } else if (modal.webkitRequestFullscreen) { // Safari
                modal.webkitRequestFullscreen();
            } else if (modal.webkitEnterFullscreen) { // iOS Safari
                modal.webkitEnterFullscreen();
            } else if (modal.mozRequestFullScreen) { // Firefox
                modal.mozRequestFullScreen();
            } else if (modal.msRequestFullscreen) { // IE/Edge
                modal.msRequestFullscreen();
            }

            // Get chart data from existing chart and deep clone it
            const chartData = priceChartInstance.data;
            
            // Verify we have valid data
            if (!chartData || !chartData.labels || !chartData.datasets || chartData.datasets.length === 0) {
                console.error('Invalid chart data');
                closeModalChart();
                return;
            }
            
            // Deep clone data to avoid Chart.js reference issues
            const clonedLabels = [...chartData.labels];
            const clonedDatasets = chartData.datasets.map(dataset => {
                // Create a completely new dataset object
                const newDataset = {
                    label: dataset.label,
                    data: [...dataset.data], // Clone data array
                    borderColor: dataset.borderColor,
                    backgroundColor: dataset.backgroundColor,
                    borderWidth: dataset.borderWidth,
                    fill: dataset.fill,
                    tension: dataset.tension,
                    pointRadius: dataset.pointRadius,
                    pointHoverRadius: dataset.pointHoverRadius,
                    spanGaps: dataset.spanGaps,
                    hidden: false // Reset hidden state for modal - show all datasets
                };
                
                // Copy borderDash if it exists
                if (dataset.borderDash) {
                    newDataset.borderDash = [...dataset.borderDash];
                }
                
                return newDataset;
            });
            
            // Determine if dark mode
            const isDark = document.body.classList.contains('dark-mode') || 
                           (!document.body.classList.contains('light-mode') && 
                            window.matchMedia('(prefers-color-scheme: dark)').matches);
            
            const textColor = isDark ? '#d0d0d0' : '#333';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.15)';
            
            // Use taller aspect ratio for modal (more vertical space)
            const aspectRatio = 0.7;
            
            // Create new chart in modal with cloned data
            priceChartModalInstance = new Chart(modalCanvas, {
                type: 'line',
                data: {
                    labels: clonedLabels,
                    datasets: clonedDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: aspectRatio,
                    plugins: {
                        legend: {
                            display: chartData.datasets.length > 1,
                            position: 'top',
                            labels: {
                                color: textColor,
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 14
                                }
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return formatPrice(context.parsed.y);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: textColor,
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 30,
                                font: {
                                    size: 12
                                }
                            },
                            grid: {
                                color: gridColor
                            }
                        },
                        y: {
                            ticks: {
                                color: textColor,
                                callback: function(value) {
                                    return formatPriceCompact(value);
                                },
                                font: {
                                    size: 12
                                }
                            },
                            grid: {
                                color: gridColor
                            }
                        }
                    }
                }
            });
            
            // Resize chart after creation to ensure proper rendering
            if (priceChartModalInstance) {
                priceChartModalInstance.resize();
            }
        }

        // Close modal
        function closeModalChart() {
            const modal = document.getElementById('chartModal');
            
            // Exit fullscreen if in fullscreen mode
            if (document.fullscreenElement || document.webkitFullscreenElement || 
                document.mozFullScreenElement || document.msFullscreenElement) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
            
            // Destroy modal chart to free memory
            if (priceChartModalInstance) {
                try {
                    priceChartModalInstance.destroy();
                } catch (e) {
                    console.error('Error destroying modal chart:', e);
                }
                priceChartModalInstance = null;
            }
            
            // Remove canvas element completely
            const modalCanvas = document.getElementById('priceChartModal');
            if (modalCanvas) {
                modalCanvas.remove();
            }
            
            // Hide modal and reset styles
            modal.style.display = 'none';
            document.body.classList.remove('modal-open');
            document.body.style.overflow = ''; // Restore scrolling
        }

        function displayResult(results, originalPrice, purchaseYear, purchaseMonth, shouldScroll = true) {
            const resultDiv = document.getElementById('result');
            const resultPrice = document.getElementById('resultPrice');
            const resultChange = document.getElementById('resultChange');
            const resultInfo = document.getElementById('resultInfo');

            let finalPrice, usedIndex, usedIndexData, purchaseIndexValue;
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            const currentMonth = currentDate.getMonth() + 1;

            // Collect all calculated prices to find the highest one
            let candidates = [];
            
            // Check if using old market index (before 2011)
            if (results.vanhatMarkkinahinta) {
                candidates.push({
                    price: results.vanhatMarkkinahinta.price,
                    name: 'Vanhojen osakeasuntojen hintaindeksi (markkinahintaindeksi)',
                    type: 'vanhatMarkkinahinta',
                    data: results.vanhatMarkkinahinta
                });
            }
            
            // For 2011 and later
            if (results.rakennuskustannus) {
                candidates.push({
                    price: results.rakennuskustannus.price,
                    name: 'Rakennuskustannusindeksi',
                    type: 'rakennuskustannus',
                    data: results.rakennuskustannus
                });
            }
            
            if (results.markkinahinta) {
                candidates.push({
                    price: results.markkinahinta.price,
                    name: 'Markkinahintaindeksi',
                    type: 'markkinahinta',
                    data: results.markkinahinta
                });
            }
            
            // Always check rajaneliöhinta (applies to all apartments)
            if (results.rajaneliohinta) {
                candidates.push({
                    price: results.rajaneliohinta.price,
                    name: 'Rajaneliöhinta',
                    type: 'rajaneliohinta',
                    data: results.rajaneliohinta
                });
            }
            
            if (candidates.length === 0) {
                resultInfo.innerHTML = '<div class="warning">Virhe: Indeksitietoja ei löydy valitulle ajankohdalle.</div>';
                resultDiv.classList.add('show');
                return;
            }
            
            // Find the highest price
            const winner = candidates.reduce((max, current) => 
                current.price > max.price ? current : max
            );
            
            finalPrice = winner.price;
            usedIndex = winner.name;
            
            // Set legacy variables for display compatibility
            if (winner.type === 'vanhatMarkkinahinta' || winner.type === 'rakennuskustannus' || winner.type === 'markkinahinta') {
                usedIndexData = winner.data.currentIndex;
                purchaseIndexValue = winner.data.purchaseIndex;
            }

            resultPrice.textContent = formatPrice(finalPrice);

            // Get improvements total
            const improvementsTotal = results.improvements ? results.improvements.totalIndexedValue : 0;
            
            // Calculate base price without improvements (for change calculation)
            const basePrice = finalPrice - improvementsTotal;
            const priceChange = basePrice - originalPrice;
            const percentageChange = ((priceChange / originalPrice) * 100).toFixed(1);
            const changeSign = priceChange >= 0 ? '+' : '';
            const changeColor = priceChange >= 0 ? '#27ae60' : '#e74c3c';

            // Display change
            resultChange.innerHTML = `<span style="color: ${changeColor};">${changeSign}${formatPrice(Math.abs(priceChange))} (${changeSign}${percentageChange}%)</span>`;
            
            // Display improvements separately if they exist
            const resultImprovements = document.getElementById('resultImprovements');
            if (improvementsTotal > 0) {
                resultImprovements.style.display = 'block';
                resultImprovements.innerHTML = `<span style="color: #666;">sis. ${formatPrice(improvementsTotal)} parannukset</span>`;
            } else {
                resultImprovements.style.display = 'none';
            }

            let infoHTML = `
                Alkuperäinen velaton hankintahinta: ${formatPrice(originalPrice)}<br>
                Valmistumispäivä: ${monthNames[purchaseMonth - 1]} ${purchaseYear}<br>
                <br>
            `;

            // Show old market index calculation for pre-2011 apartments
            if (results.vanhatMarkkinahinta) {
                const vm = results.vanhatMarkkinahinta;
                const basePrice = (originalPrice * vm.currentIndex.value) / vm.purchaseIndex;
                const improvementsTotal = results.improvements ? results.improvements.totalIndexedValue : 0;
                
                // Check if old market index is using older data
                const vmIsOld = vm.currentIndex.year < currentYear || 
                                (vm.currentIndex.year === currentYear && vm.currentIndex.month < currentMonth);
                
                infoHTML += `
                    <strong>${usedIndex}:</strong> ✓ (käytetty) 
                    <a href="./graphs/#old-indices-chart">(katso graafi →)</a><br>
                    <div style="padding-left: 20px; margin-top: 8px;">
                        <em>Ennen 1.1.2011 valmistuneille Hitas-asunnoille käytetään yhtä indeksiä</em><br>
                        <br>
                        Valmistumishetken indeksi: ${vm.purchaseIndex.toFixed(2)}<br>
                        Nykyinen indeksi: ${vm.currentIndex.value.toFixed(2)} (${monthNames[vm.currentIndex.month - 1]} ${vm.currentIndex.year})<br>
                        Kaava: ${vm.currentIndex.value.toFixed(2)} / ${vm.purchaseIndex.toFixed(2)} × ${formatPrice(originalPrice)}<br>
                        Indeksipohjainen hinta: ${formatPrice(basePrice)}<br>
                `;
                
                if (improvementsTotal > 0) {
                    infoHTML += `
                        + Parannukset: ${formatPrice(improvementsTotal)}<br>
                    `;
                }
                
                infoHTML += `
                        Tulos: ${formatPrice(vm.price)}<br>
                    </div>
                `;
                
                if (vmIsOld) {
                    infoHTML += `
                        <div class="warning" style="margin-top: 10px; margin-bottom: 10px;">
                            ⚠️ Huom: Laskettu ${monthNames[vm.currentIndex.month - 1]} ${vm.currentIndex.year} indeksin mukaan, 
                            koska ${monthNames[currentMonth - 1]} ${currentYear} indeksiä ei ole vielä saatavilla.
                        </div>
                    `;
                }
            }
            // Show both index calculations for post-2011 apartments
            else if (results.rakennuskustannus) {
                const rk = results.rakennuskustannus;
                const isSelected = usedIndex === 'Rakennuskustannusindeksi';
                const basePrice = (originalPrice * rk.currentIndex.value) / rk.purchaseIndex;
                const improvementsTotal = results.improvements ? results.improvements.totalIndexedValue : 0;
                
                // Check if Rakennuskustannus index is using older data
                const rkIsOld = rk.currentIndex.year < currentYear || 
                                (rk.currentIndex.year === currentYear && rk.currentIndex.month < currentMonth);
                
                infoHTML += `
                    <strong>Rakennuskustannusindeksi:</strong> ${isSelected ? '✓ (käytetty)' : ''} 
                    <a href="./graphs/#new-indices-chart">(katso graafi →)</a><br>
                    <div style="padding-left: 20px; margin-top: 8px;">
                        Valmistumishetken indeksi: ${rk.purchaseIndex.toFixed(2)}<br>
                        Nykyinen indeksi: ${rk.currentIndex.value.toFixed(2)} (${monthNames[rk.currentIndex.month - 1]} ${rk.currentIndex.year})<br>
                        Kaava: ${rk.currentIndex.value.toFixed(2)} / ${rk.purchaseIndex.toFixed(2)} × ${formatPrice(originalPrice)}<br>
                        Indeksipohjainen hinta: ${formatPrice(basePrice)}<br>
                `;
                
                if (improvementsTotal > 0) {
                    infoHTML += `
                        + Parannukset: ${formatPrice(improvementsTotal)}<br>
                    `;
                }
                
                infoHTML += `
                        Tulos: ${formatPrice(rk.price)}<br>
                    </div>
                `;
                
                if (rkIsOld) {
                    infoHTML += `
                        <div class="warning" style="margin-top: 10px; margin-bottom: 10px;">
                            ⚠️ Huom: Laskettu ${monthNames[rk.currentIndex.month - 1]} ${rk.currentIndex.year} indeksin mukaan, 
                            koska ${monthNames[currentMonth - 1]} ${currentYear} indeksiä ei ole vielä saatavilla.
                        </div>
                    `;
                }
                
                infoHTML += '<br>';
            }

            if (results.markkinahinta) {
                const mh = results.markkinahinta;
                const isSelected = usedIndex === 'Markkinahintaindeksi';
                const basePrice = (originalPrice * mh.currentIndex.value) / mh.purchaseIndex;
                const improvementsTotal = results.improvements ? results.improvements.totalIndexedValue : 0;
                
                // Check if Markkinahinta index is using older data
                const mhIsOld = mh.currentIndex.year < currentYear || 
                                (mh.currentIndex.year === currentYear && mh.currentIndex.month < currentMonth);
                
                infoHTML += `
                    <strong>Markkinahintaindeksi:</strong> ${isSelected ? '✓ (käytetty)' : ''} 
                    <a href="./graphs/#new-indices-chart">(katso graafi →)</a><br>
                    <div style="padding-left: 20px; margin-top: 8px;">
                        Valmistumishetken indeksi: ${mh.purchaseIndex.toFixed(2)}<br>
                        Nykyinen indeksi: ${mh.currentIndex.value.toFixed(2)} (${monthNames[mh.currentIndex.month - 1]} ${mh.currentIndex.year})<br>
                        Kaava: ${mh.currentIndex.value.toFixed(2)} / ${mh.purchaseIndex.toFixed(2)} × ${formatPrice(originalPrice)}<br>
                        Indeksipohjainen hinta: ${formatPrice(basePrice)}<br>
                `;
                
                if (improvementsTotal > 0) {
                    infoHTML += `
                        + Parannukset: ${formatPrice(improvementsTotal)}<br>
                    `;
                }
                
                infoHTML += `
                        Tulos: ${formatPrice(mh.price)}<br>
                    </div>
                `;
                
                if (mhIsOld) {
                    infoHTML += `
                        <div class="warning" style="margin-top: 10px; margin-bottom: 10px;">
                            ⚠️ Huom: Laskettu ${monthNames[mh.currentIndex.month - 1]} ${mh.currentIndex.year} indeksin mukaan, 
                            koska ${monthNames[currentMonth - 1]} ${currentYear} indeksiä ei ole vielä saatavilla.
                        </div>
                    `;
                }
            }

            // Show rajaneliöhinta calculation
            if (results.rajaneliohinta) {
                const rh = results.rajaneliohinta;
                const isSelected = usedIndex === 'Rajaneliöhinta';
                
                infoHTML += `
                    <br>
                    <strong>Rajaneliöhinta:</strong> ${isSelected ? '✓ (käytetty)' : ''}<br>
                    <div style="padding-left: 20px; margin-top: 8px;">
                        <em>Kaikkien Hitas-yhtiöiden keskimääräinen neliöhinta</em><br>
                        <a href="graphs/#rajaneliohinta-chart" target="_blank" rel="noopener" style="font-size: 13px; margin-top: 4px; display: inline-block;">Katso graafi →</a><br>
                        <br>
                        Asunnon pinta-ala: ${rh.apartmentSize} m²<br>
                        Rajaneliöhinta: ${formatPrice(rh.pricePerSqm)}/m² (voimassa ${rh.validFrom} - ${rh.validUntil})<br>
                        Kaava: ${rh.apartmentSize} m² × ${formatPrice(rh.pricePerSqm)}/m²<br>
                        Tulos: ${formatPrice(rh.price)}<br>
                    </div>
                `;
            }

            // Show improvements
            if (results.improvements && results.improvements.improvements.length > 0) {
                const improvementsData = results.improvements;
                infoHTML += `
                    <br>
                    <strong>Parannukset:</strong><br>
                    <div style="padding-left: 20px; margin-top: 8px;">
                        <em>Parannukset lisätään vain indeksihintoihin, ei rajaneliöhintaan</em><br>
                        <br>
                `;
                
                improvementsData.improvements.forEach((imp, index) => {
                    infoHTML += `
                        <div class="improvement-detail-box">
                            <strong>Parannus ${index + 1}</strong> (${monthNames[imp.improvementMonth - 1]} ${imp.improvementYear})<br>
                            Parannuksen hinta: ${formatPrice(imp.originalPrice)}<br>
                            Omavastuu (30 €/m²): ${formatPrice(imp.omavastuu)}<br>
                    `;
                    
                    if (imp.indexedValue > 0) {
                        infoHTML += `
                            Indeksitarkistettava summa: ${formatPrice(imp.indexedAmount)}<br>
                            Käytetty indeksi: ${imp.usedIndex.name}<br>
                            Indeksitarkistettu arvo: ${formatPrice(imp.indexedValue)}<br>
                        `;
                    } else {
                        infoHTML += `
                            <em>Ei indeksitarkistusta (hinta ≤ omavastuu)</em><br>
                        `;
                    }
                    
                    infoHTML += `</div>`;
                });
                
                infoHTML += `
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(0,0,0,0.1);">
                            <strong>Parannusten yhteensä indeksitarkistettu arvo: ${formatPrice(improvementsData.totalIndexedValue)}</strong><br>
                            <em>Tämä summa on lisätty kaikkiin indeksihintoihin</em>
                        </div>
                    </div>
                `;
            }

            infoHTML = infoHTML.trim();

            resultInfo.innerHTML = infoHTML;
            resultDiv.classList.add('show');
            
            // Get apartment size from results if available
            const apartmentSize = results.rajaneliohinta ? results.rajaneliohinta.apartmentSize : null;
            
            // Create price evolution chart
            createPriceChart(purchaseYear, purchaseMonth, originalPrice, apartmentSize, winner);
            
            // Hide chart note (no longer needed since rajaneliöhinta is shown in the chart)
            const chartNote = document.getElementById('chartNote');
            chartNote.style.display = 'none';
            
            // Scroll to result only if requested (not on auto-load)
            if (shouldScroll) {
                setTimeout(() => {
                    resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
            }
        }

        // Handle form submission
        document.getElementById('calculatorForm').addEventListener('submit', function(e) {
            e.preventDefault();

            const originalPrice = parseFloat(document.getElementById('originalPrice').value);
            const apartmentSize = parseFloat(document.getElementById('apartmentSize').value);
            const purchaseYear = parseInt(document.getElementById('purchaseYear').value);
            const purchaseMonth = parseInt(document.getElementById('purchaseMonth').value);
            const improvements = getImprovements();

            // Calculate
            // Check if indices are loaded
            if (!indicesLoaded) {
                alert('Virhe: Indeksit eivät ole vielä ladattu. Odota hetki ja yritä uudelleen.');
                return;
            }
            
            // Validate that we have required indices
            if (!rakennuskustannusindeksi || Object.keys(rakennuskustannusindeksi).length === 0 ||
                !markkinahintaindeksi || Object.keys(markkinahintaindeksi).length === 0) {
                alert('Virhe: Vaaditut indeksit puuttuvat. Päivitä sivu ja yritä uudelleen.');
                return;
            }

            const results = calculateRajahinta(originalPrice, purchaseYear, purchaseMonth, apartmentSize, improvements);

            // Track calculation event in Google Analytics (if consent given)
            if (typeof window.gtag === 'function') {
                window.gtag('event', 'calculation', {
                    'event_category': 'calculator',
                    'event_label': 'price_calculation',
                    'value': Math.round(results.finalPrice || 0),
                    'non_interaction': false
                });
            }

            // Display result
            displayResult(results, originalPrice, purchaseYear, purchaseMonth);

            // Save to localStorage
            saveToLocalStorage({
                originalPrice,
                apartmentSize,
                purchaseYear,
                purchaseMonth,
                improvements
            });
        });

        // Theme toggle functionality (define before DOMContentLoaded)
        let isInitialThemeLoad = true;
        
        function setTheme(theme, isUserAction = false) {
            const lightIcon = document.getElementById('lightIcon');
            const darkIcon = document.getElementById('darkIcon');
            let actualTheme = theme;
            
            if (theme === 'dark') {
                document.documentElement.classList.add('dark-mode');
                document.documentElement.classList.remove('light-mode');
                document.body.classList.add('dark-mode');
                document.body.classList.remove('light-mode');
                if (lightIcon) lightIcon.classList.remove('active');
                if (darkIcon) darkIcon.classList.add('active');
                localStorage.setItem('theme', 'dark');
                actualTheme = 'dark';
            } else if (theme === 'light') {
                document.documentElement.classList.add('light-mode');
                document.documentElement.classList.remove('dark-mode');
                document.body.classList.add('light-mode');
                document.body.classList.remove('dark-mode');
                if (lightIcon) lightIcon.classList.add('active');
                if (darkIcon) darkIcon.classList.remove('active');
                localStorage.setItem('theme', 'light');
                actualTheme = 'light';
            } else {
                // Auto mode - follow system preference
                document.documentElement.classList.remove('dark-mode', 'light-mode');
                document.body.classList.remove('dark-mode', 'light-mode');
                const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                if (lightIcon) lightIcon.classList.toggle('active', !isDark);
                if (darkIcon) darkIcon.classList.toggle('active', isDark);
                localStorage.removeItem('theme');
                actualTheme = isDark ? 'dark' : 'light';
            }
            
            // Track theme usage in Google Analytics (if consent given)
            if (typeof window.gtag === 'function') {
                window.gtag('event', 'theme_change', {
                    'event_category': 'ui',
                    'event_label': actualTheme,
                    'value': actualTheme === 'dark' ? 1 : 0,
                    'non_interaction': !isUserAction && isInitialThemeLoad
                });
            }
            
            // Mark that initial load is done
            if (isInitialThemeLoad) {
                isInitialThemeLoad = false;
            }
            
            // Recreate chart with new theme colors if it exists
            if (currentChartData) {
                createPriceChart(
                    currentChartData.purchaseYear,
                    currentChartData.purchaseMonth,
                    currentChartData.originalPrice,
                    currentChartData.apartmentSize || null,
                    currentChartData.winner || null
                );
                
                // Recreate modal chart if it's open
                const chartModal = document.getElementById('chartModal');
                if (chartModal && chartModal.style.display === 'flex' && priceChartInstance) {
                    createModalChart();
                }
            }
        }

        function toggleTheme() {
            const currentTheme = localStorage.getItem('theme');
            
            // Check if currently in dark mode (either manually set or from system preference)
            const isDarkNow = document.body.classList.contains('dark-mode') || 
                             (!document.body.classList.contains('light-mode') && 
                              window.matchMedia('(prefers-color-scheme: dark)').matches);
            
            // Toggle between dark and light
            if (isDarkNow) {
                setTheme('light', true); // true = user action
            } else {
                setTheme('dark', true); // true = user action
            }
        }

        // Calculation toggle functionality
        function toggleCalculation() {
            const resultInfo = document.getElementById('resultInfo');
            const arrow = document.querySelector('.toggle-arrow');
            const toggleBtn = document.getElementById('calculationToggle');
            
            if (resultInfo && arrow && toggleBtn) {
                const isExpanded = resultInfo.classList.toggle('expanded');
                arrow.classList.toggle('expanded');
                
                // Update ARIA attributes for accessibility
                toggleBtn.setAttribute('aria-expanded', isExpanded);
                resultInfo.setAttribute('aria-hidden', !isExpanded);
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async function() {
            const themeToggle = document.getElementById('themeToggle');
            
            if (themeToggle) {
                themeToggle.addEventListener('click', toggleTheme);
            }

            // Limit input length for number inputs
            const originalPriceInput = document.getElementById('originalPrice');
            const apartmentSizeInput = document.getElementById('apartmentSize');

            if (originalPriceInput) {
                originalPriceInput.addEventListener('input', function(e) {
                    const value = e.target.value;
                    if (value === '') return;
                    // Count digits in the value (excluding decimal point)
                    const digitsOnly = value.replace(/\D/g, '');
                    if (digitsOnly.length > 9) {
                        // Limit to 9 digits
                        const prevValue = e.target.dataset.prevValue || '';
                        e.target.value = prevValue;
                    } else {
                        e.target.dataset.prevValue = value;
                    }
                });
            }

            if (apartmentSizeInput) {
                apartmentSizeInput.addEventListener('input', function(e) {
                    const value = e.target.value;
                    if (value === '') return;
                    // Count digits before decimal point (integer part)
                    const parts = value.split('.');
                    const integerPart = parts[0];
                    if (integerPart && integerPart.length > 4) {
                        // Limit to 4 digits in integer part
                        const prevValue = e.target.dataset.prevValue || '';
                        e.target.value = prevValue;
                    } else {
                        e.target.dataset.prevValue = value;
                    }
                });
            }

            // Full-screen chart modal functionality
            const fullscreenBtn = document.getElementById('fullscreenChartBtn');
            const closeModalBtn = document.getElementById('closeChartModal');
            const chartModal = document.getElementById('chartModal');

            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', createModalChart);
            }

            if (closeModalBtn) {
                closeModalBtn.addEventListener('click', closeModalChart);
            }

            // Close modal on ESC key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && chartModal && chartModal.style.display === 'flex') {
                    closeModalChart();
                }
            });

            // Handle fullscreen change events
            const fullscreenChangeEvents = ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'];
            fullscreenChangeEvents.forEach(eventName => {
                document.addEventListener(eventName, function() {
                    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || 
                                           document.mozFullScreenElement || document.msFullscreenElement);
                    // If user exits fullscreen (e.g., via browser UI), close modal
                    if (!isFullscreen && chartModal && chartModal.style.display === 'flex') {
                        closeModalChart();
                    }
                });
            });

            // Close modal when clicking outside the chart
            if (chartModal) {
                chartModal.addEventListener('click', function(e) {
                    if (e.target === chartModal) {
                        closeModalChart();
                    }
                });
            }

            // Handle window resize to update charts
            let resizeTimeout;
            window.addEventListener('resize', function() {
                // Debounce resize events
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function() {
                    // Resize main chart if it exists
                    if (priceChartInstance) {
                        priceChartInstance.resize();
                    }
                    // Resize modal chart if it exists and is visible
                    if (priceChartModalInstance && chartModal && chartModal.style.display === 'flex') {
                        priceChartModalInstance.resize();
                    }
                }, 150);
            });

            // Handle orientation change (mobile)
            window.addEventListener('orientationchange', function() {
                setTimeout(function() {
                    if (priceChartInstance) {
                        priceChartInstance.resize();
                    }
                    if (priceChartModalInstance && chartModal && chartModal.style.display === 'flex') {
                        priceChartModalInstance.resize();
                    }
                }, 200);
            });

            // Initialize theme
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                setTheme(savedTheme);
            } else {
                setTheme(null); // Auto mode
            }

            // Setup calculation toggle
            const calculationToggle = document.getElementById('calculationToggle');
            if (calculationToggle) {
                calculationToggle.addEventListener('click', toggleCalculation);
            }

            initializeYearDropdown();

            // Setup "Add improvement" button
            const addImprovementBtn = document.getElementById('addImprovementBtn');
            if (addImprovementBtn) {
                addImprovementBtn.addEventListener('click', function() {
                    addImprovement();
                });
            }

            // Lataa indeksit ensin
            await loadIndices();

            // Load saved data and auto-calculate
            const savedData = loadFromLocalStorage();
            if (savedData && indicesLoaded) {
                document.getElementById('originalPrice').value = savedData.originalPrice;
                if (savedData.apartmentSize) {
                    document.getElementById('apartmentSize').value = savedData.apartmentSize;
                }
                document.getElementById('purchaseYear').value = savedData.purchaseYear;
                document.getElementById('purchaseMonth').value = savedData.purchaseMonth;

                // Load improvements
                if (savedData.improvements && savedData.improvements.length > 0) {
                    savedData.improvements.forEach(improvement => {
                        addImprovement(improvement);
                    });
                }

                // Auto-calculate without scrolling (only if apartment size is available)
                if (savedData.apartmentSize) {
                    const improvements = savedData.improvements || [];
                    const results = calculateRajahinta(
                        savedData.originalPrice,
                        savedData.purchaseYear,
                        savedData.purchaseMonth,
                        savedData.apartmentSize,
                        improvements
                    );
                    
                    // Track auto-calculation event in Google Analytics (if consent given)
                    if (typeof window.gtag === 'function') {
                        window.gtag('event', 'auto_calculation', {
                            'event_category': 'calculator',
                            'event_label': 'auto_price_calculation',
                            'value': Math.round(results.finalPrice || 0),
                            'non_interaction': true
                        });
                    }
                    
                    displayResult(results, savedData.originalPrice, savedData.purchaseYear, savedData.purchaseMonth, false);
                }
            }
        });

        // Cookie Consent Management
        function loadGoogleAnalytics() {
            // Load Google Analytics script
            const script1 = document.createElement('script');
            script1.async = true;
            script1.src = 'https://www.googletagmanager.com/gtag/js?id=G-SBRC1GSMZS';
            document.head.appendChild(script1);

            // Initialize gtag
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            window.gtag = gtag;
            gtag('js', new Date());
            gtag('config', 'G-SBRC1GSMZS');
        }

        function initCookieConsent() {
            const consent = localStorage.getItem('cookieConsent');
            const banner = document.getElementById('cookieConsent');

            if (!consent && banner) {
                banner.classList.add('show');
            } else if (consent === 'accepted') {
                loadGoogleAnalytics();
            }
        }

        function acceptCookies() {
            localStorage.setItem('cookieConsent', 'accepted');
            const banner = document.getElementById('cookieConsent');
            if (banner) {
                banner.classList.remove('show');
            }
            loadGoogleAnalytics();
        }

        function declineCookies() {
            localStorage.setItem('cookieConsent', 'declined');
            const banner = document.getElementById('cookieConsent');
            if (banner) {
                banner.classList.remove('show');
            }
        }

        // Initialize cookie consent on page load
        document.addEventListener('DOMContentLoaded', function() {
            initCookieConsent();

            const acceptBtn = document.getElementById('cookieAccept');
            const declineBtn = document.getElementById('cookieDecline');

            if (acceptBtn) {
                acceptBtn.addEventListener('click', acceptCookies);
            }

            if (declineBtn) {
                declineBtn.addEventListener('click', declineCookies);
            }
        });

    </script>

    <!-- Cookie Consent Banner -->
    <div id="cookieConsent" class="cookie-consent">
        <div class="cookie-consent-content">
            <div class="cookie-consent-text">
                Tämä sivusto käyttää evästeitä käyttökokemuksen parantamiseksi ja sivuston käytön analysoimiseksi. 
                Hyväksymällä evästeet sallit Google Analyticsin käytön. 
                Voit lukea lisää <a href="https://policies.google.com/privacy" target="_blank" rel="noopener">tietosuojakäytännöstä</a>.
            </div>
            <div class="cookie-consent-buttons">
                <button id="cookieAccept" class="cookie-consent-btn accept">Hyväksy</button>
                <button id="cookieDecline" class="cookie-consent-btn decline">Hylkää</button>
            </div>
        </div>
    </div>
    <script type="module" src="js/main.js"></script>
</body>
</html>

